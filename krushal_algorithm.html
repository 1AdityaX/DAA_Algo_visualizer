<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruskal's Algorithm Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .code-line {
            transition: background-color 0.3s ease;
        }
        .code-line.active {
            background-color: #fef3c7;
            border-left: 4px solid #f59e0b;
        }
        .edge {
            stroke-width: 3;
            cursor: pointer;
        }
        .edge.selected {
            stroke: #10b981;
            stroke-width: 5;
        }
        .edge.rejected {
            stroke: #ef4444;
            stroke-dasharray: 5,5;
        }
        .vertex {
            cursor: pointer;
        }
        .tooltip {
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <!-- Header -->
        <header class="mb-6">
            <h1 class="text-4xl font-bold text-slate-800 mb-2">Kruskal's Algorithm Visualizer</h1>
            <p class="text-slate-600">Find the Minimum Spanning Tree using Kruskal's greedy approach</p>
        </header>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Left Panel: Pseudocode & Controls -->
            <div class="space-y-6">
                <!-- Controls -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4">Controls</h2>
                    <div class="flex flex-wrap gap-3">
                        <button id="startBtn" class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium">
                            Start
                        </button>
                        <button id="pauseBtn" class="px-6 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors font-medium" disabled>
                            Pause
                        </button>
                        <button id="stepBtn" class="px-6 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium">
                            Step
                        </button>
                        <button id="resetBtn" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors font-medium">
                            Reset
                        </button>
                    </div>
                    <div class="mt-4">
                        <label class="block text-sm font-medium text-slate-700 mb-2">Animation Speed</label>
                        <input id="speedSlider" type="range" min="500" max="3000" value="1500" step="100" class="w-full">
                        <div class="flex justify-between text-xs text-slate-500 mt-1">
                            <span>Fast</span>
                            <span>Slow</span>
                        </div>
                    </div>
                </div>

                <!-- Algorithm Info -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-3">Algorithm Status</h2>
                    <div class="space-y-2">
                        <div class="flex justify-between items-center">
                            <span class="text-slate-600">Step:</span>
                            <span id="stepCount" class="font-mono font-semibold text-slate-800">0</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-slate-600">Edges in MST:</span>
                            <span id="mstCount" class="font-mono font-semibold text-green-600">0 / 4</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-slate-600">Total Weight:</span>
                            <span id="totalWeight" class="font-mono font-semibold text-blue-600">0</span>
                        </div>
                    </div>
                </div>

                <!-- Complexity Analysis -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-3">Complexity Analysis</h2>
                    <div class="space-y-2">
                        <div>
                            <span class="font-medium text-slate-700">Time Complexity:</span>
                            <span class="ml-2 font-mono text-blue-600">O(E log E)</span>
                        </div>
                        <div>
                            <span class="font-medium text-slate-700">Space Complexity:</span>
                            <span class="ml-2 font-mono text-blue-600">O(V + E)</span>
                        </div>
                        <p class="text-sm text-slate-600 mt-2">Where E = edges, V = vertices</p>
                    </div>
                </div>

                <!-- Pseudocode -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4">Pseudocode</h2>
                    <div class="bg-slate-50 rounded-lg p-4 font-mono text-sm space-y-1">
                        <div class="code-line px-2 py-1 rounded" data-line="0">1. Sort all edges by weight (ascending)</div>
                        <div class="code-line px-2 py-1 rounded" data-line="1">2. Initialize parent array for Union-Find</div>
                        <div class="code-line px-2 py-1 rounded" data-line="2">3. FOR each edge in sorted edges:</div>
                        <div class="code-line px-2 py-1 rounded pl-8" data-line="3">4.   Find parent of both vertices</div>
                        <div class="code-line px-2 py-1 rounded pl-8" data-line="4">5.   IF vertices in different sets:</div>
                        <div class="code-line px-2 py-1 rounded pl-12" data-line="5">6.     Add edge to MST</div>
                        <div class="code-line px-2 py-1 rounded pl-12" data-line="6">7.     Union the two sets</div>
                        <div class="code-line px-2 py-1 rounded pl-8" data-line="7">8.   ELSE: Skip edge (creates cycle)</div>
                        <div class="code-line px-2 py-1 rounded" data-line="8">9. Return MST</div>
                    </div>
                </div>

                <!-- Step Explanation -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-3">Current Step Explanation</h2>
                    <p id="stepExplanation" class="text-slate-700 leading-relaxed">Click Start or Step to begin the visualization.</p>
                </div>
            </div>

            <!-- Right Panel: Graph Visualization -->
            <div class="space-y-6">
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4">Graph Visualization</h2>
                    <svg id="graphSvg" width="100%" height="500" class="border-2 border-slate-200 rounded-lg bg-slate-50"></svg>
                </div>

                <!-- Edge List -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-xl font-semibold text-slate-800 mb-4">Edge Processing Order</h2>
                    <div id="edgeList" class="space-y-2 max-h-64 overflow-y-auto"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Graph data structure
        const graph = {
            vertices: [
                { id: 'A', x: 150, y: 100 },
                { id: 'B', x: 400, y: 100 },
                { id: 'C', x: 150, y: 300 },
                { id: 'D', x: 400, y: 300 },
                { id: 'E', x: 275, y: 200 }
            ],
            edges: [
                { from: 'A', to: 'B', weight: 4 },
                { from: 'A', to: 'E', weight: 1 },
                { from: 'B', to: 'E', weight: 2 },
                { from: 'B', to: 'D', weight: 5 },
                { from: 'E', to: 'C', weight: 3 },
                { from: 'E', to: 'D', weight: 6 },
                { from: 'C', to: 'D', weight: 7 },
                { from: 'A', to: 'C', weight: 8 }
            ]
        };

        // Algorithm state
        let state = {
            sortedEdges: [],
            parent: {},
            mst: [],
            currentStep: 0,
            totalWeight: 0,
            currentLine: -1,
            isRunning: false,
            isPaused: false
        };

        // UI elements
        const svg = document.getElementById('graphSvg');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const speedSlider = document.getElementById('speedSlider');
        const stepCount = document.getElementById('stepCount');
        const mstCount = document.getElementById('mstCount');
        const totalWeightEl = document.getElementById('totalWeight');
        const stepExplanation = document.getElementById('stepExplanation');
        const edgeList = document.getElementById('edgeList');

        // Union-Find operations
        function find(node) {
            if (state.parent[node] !== node) {
                state.parent[node] = find(state.parent[node]);
            }
            return state.parent[node];
        }

        function union(node1, node2) {
            const root1 = find(node1);
            const root2 = find(node2);
            state.parent[root1] = root2;
        }

        // Initialize the graph visualization
        function initGraph() {
            svg.innerHTML = '';
            
            // Draw edges
            graph.edges.forEach((edge, idx) => {
                const v1 = graph.vertices.find(v => v.id === edge.from);
                const v2 = graph.vertices.find(v => v.id === edge.to);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', v1.x);
                line.setAttribute('y1', v1.y);
                line.setAttribute('x2', v2.x);
                line.setAttribute('y2', v2.y);
                line.setAttribute('stroke', '#94a3b8');
                line.setAttribute('class', 'edge');
                line.setAttribute('data-edge', idx);
                svg.appendChild(line);

                // Edge weight label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', (v1.x + v2.x) / 2);
                text.setAttribute('y', (v1.y + v2.y) / 2 - 8);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('class', 'fill-slate-700 font-bold text-sm');
                text.textContent = edge.weight;
                svg.appendChild(text);
            });

            // Draw vertices
            graph.vertices.forEach(vertex => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', vertex.x);
                circle.setAttribute('cy', vertex.y);
                circle.setAttribute('r', 25);
                circle.setAttribute('fill', '#3b82f6');
                circle.setAttribute('class', 'vertex');
                svg.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', vertex.x);
                text.setAttribute('y', vertex.y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('class', 'fill-white font-bold text-lg pointer-events-none');
                text.textContent = vertex.id;
                svg.appendChild(text);
            });
        }

        // Initialize algorithm state
        function initAlgorithm() {
            state.sortedEdges = [...graph.edges].sort((a, b) => a.weight - b.weight);
            state.parent = {};
            graph.vertices.forEach(v => state.parent[v.id] = v.id);
            state.mst = [];
            state.currentStep = 0;
            state.totalWeight = 0;
            state.currentLine = -1;
            state.isRunning = false;
            state.isPaused = false;

            updateUI();
            initGraph();
            displayEdgeList();
        }

        // Display sorted edge list
        function displayEdgeList() {
            edgeList.innerHTML = '';
            state.sortedEdges.forEach((edge, idx) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center p-3 bg-slate-50 rounded-lg';
                div.id = `edge-item-${idx}`;
                div.innerHTML = `
                    <span class="font-mono">${edge.from} — ${edge.to}</span>
                    <span class="font-mono font-semibold text-blue-600">Weight: ${edge.weight}</span>
                `;
                edgeList.appendChild(div);
            });
        }

        // Highlight code line
        function highlightLine(lineNum) {
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('active');
            });
            if (lineNum >= 0) {
                const line = document.querySelector(`[data-line="${lineNum}"]`);
                if (line) line.classList.add('active');
            }
            state.currentLine = lineNum;
        }

        // Update UI elements
        function updateUI() {
            stepCount.textContent = state.currentStep;
            mstCount.textContent = `${state.mst.length} / ${graph.vertices.length - 1}`;
            totalWeightEl.textContent = state.totalWeight;
        }

        // Animate edge selection
        function animateEdge(edgeIdx, isSelected) {
            const edge = state.sortedEdges[edgeIdx];
            const v1 = graph.vertices.find(v => v.id === edge.from);
            const v2 = graph.vertices.find(v => v.id === edge.to);
            
            const lines = svg.querySelectorAll('line');
            let targetLine = null;
            
            lines.forEach(line => {
                const x1 = parseFloat(line.getAttribute('x1'));
                const y1 = parseFloat(line.getAttribute('y1'));
                const x2 = parseFloat(line.getAttribute('x2'));
                const y2 = parseFloat(line.getAttribute('y2'));
                
                if ((Math.abs(x1 - v1.x) < 1 && Math.abs(y1 - v1.y) < 1 && 
                     Math.abs(x2 - v2.x) < 1 && Math.abs(y2 - v2.y) < 1) ||
                    (Math.abs(x1 - v2.x) < 1 && Math.abs(y1 - v2.y) < 1 && 
                     Math.abs(x2 - v1.x) < 1 && Math.abs(y2 - v1.y) < 1)) {
                    targetLine = line;
                }
            });

            if (targetLine) {
                gsap.to(targetLine, {
                    duration: 0.5,
                    attr: { 'stroke-width': 6 },
                    onComplete: () => {
                        if (isSelected) {
                            targetLine.classList.add('selected');
                            targetLine.setAttribute('stroke', '#10b981');
                        } else {
                            targetLine.classList.add('rejected');
                            targetLine.setAttribute('stroke', '#ef4444');
                        }
                    }
                });
            }
        }

        // Execute one step of the algorithm
        async function executeStep() {
            if (state.currentStep === 0) {
                highlightLine(0);
                stepExplanation.textContent = `Sorting all edges by weight. We have ${state.sortedEdges.length} edges to process.`;
                state.currentStep++;
                return true;
            }

            if (state.currentStep === 1) {
                highlightLine(1);
                stepExplanation.textContent = `Initializing Union-Find data structure. Each vertex starts in its own set.`;
                state.currentStep++;
                return true;
            }

            const edgeIdx = state.currentStep - 2;
            
            if (edgeIdx >= state.sortedEdges.length) {
                highlightLine(8);
                stepExplanation.textContent = `Algorithm complete! MST has ${state.mst.length} edges with total weight ${state.totalWeight}.`;
                state.isRunning = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                return false;
            }

            const edge = state.sortedEdges[edgeIdx];
            
            // Highlight current edge in list
            document.querySelectorAll('#edgeList > div').forEach((div, idx) => {
                div.classList.remove('bg-yellow-100', 'bg-green-100', 'bg-red-100');
                if (idx === edgeIdx) {
                    div.classList.add('bg-yellow-100');
                }
            });

            highlightLine(2);
            stepExplanation.textContent = `Examining edge ${edge.from}—${edge.to} with weight ${edge.weight}.`;
            await sleep(speedSlider.value / 3);

            highlightLine(3);
            const parent1 = find(edge.from);
            const parent2 = find(edge.to);
            stepExplanation.textContent = `Finding parents: ${edge.from} → ${parent1}, ${edge.to} → ${parent2}`;
            await sleep(speedSlider.value / 3);

            highlightLine(4);
            if (parent1 !== parent2) {
                highlightLine(5);
                stepExplanation.textContent = `Vertices are in different sets! Adding edge to MST.`;
                state.mst.push(edge);
                state.totalWeight += edge.weight;
                animateEdge(edgeIdx, true);
                
                document.querySelector(`#edge-item-${edgeIdx}`).classList.add('bg-green-100');
                
                await sleep(speedSlider.value / 3);
                
                highlightLine(6);
                union(edge.from, edge.to);
                stepExplanation.textContent = `Uniting sets containing ${edge.from} and ${edge.to}.`;
            } else {
                highlightLine(7);
                stepExplanation.textContent = `Edge creates a cycle! Skipping this edge.`;
                animateEdge(edgeIdx, false);
                document.querySelector(`#edge-item-${edgeIdx}`).classList.add('bg-red-100');
            }

            state.currentStep++;
            updateUI();
            return true;
        }

        // Sleep utility
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Auto-run algorithm
        async function runAlgorithm() {
            state.isRunning = true;
            state.isPaused = false;
            startBtn.disabled = true;
            pauseBtn.disabled = false;

            while (state.isRunning && !state.isPaused) {
                const hasMore = await executeStep();
                if (!hasMore) break;
                await sleep(parseInt(speedSlider.value));
            }

            if (state.isPaused) {
                startBtn.disabled = false;
                pauseBtn.disabled = true;
            }
        }

        // Event listeners
        startBtn.addEventListener('click', () => {
            if (state.currentStep === 0 || state.currentStep >= state.sortedEdges.length + 2) {
                initAlgorithm();
            }
            runAlgorithm();
        });

        pauseBtn.addEventListener('click', () => {
            state.isPaused = true;
            state.isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
        });

        stepBtn.addEventListener('click', async () => {
            if (state.currentStep === 0 || state.currentStep >= state.sortedEdges.length + 2) {
                initAlgorithm();
            }
            await executeStep();
        });

        resetBtn.addEventListener('click', () => {
            state.isRunning = false;
            state.isPaused = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            initAlgorithm();
            highlightLine(-1);
            stepExplanation.textContent = 'Click Start or Step to begin the visualization.';
        });

        // Initialize on load
        initAlgorithm();
    </script>
</body>
</html>